### 1 调优调什么

#### 1.1 内存方面

​	1 JVM需要的内存总大小

​	2 各块内存分配，新生代、老年代、存活区

​	3 选择合适的垃圾回收算法、控制GC停顿次数和时间

​	4 解决内存泄漏的问题，辅助代码优化

​	5 内存热点：检查哪些对象在系统中数量最大，辅助代码优化

#### 1.2 线程方面

​	1 死锁检查，辅助代码优化

​	2 Dump线程详细信息：查看线程内部运行情况，查找竞争线程，辅助代码优化

​	3 CPU热点：检查系统哪些方法占用了大量CPU时间，辅助代码优化

#### 1.3 如何调优

​	1 监控JVM的状态，主要是内存、线程、代码I/O几部分(结合JMC/VisualVM工具)

​	2 分析结果，判断是否需要优化

​	3 调整：垃圾回收算法和内存分配，修改并优化代码

​	4 不断的重复监控、分析和调整、直到找到优化的平衡点

### 2 调优的目标、方法、经验

#### 2.1 目标

​	1 GC的时间足够小(单次gc时间少，总gc时间少)

​	2 GC的次数足够少

​	3 将转移到老年代的对象数量降低到最小

​	4 减少Full GC的执行时间(内存小的话一般Full GC时间少，但会导致GC次数增多等问题，需要找到平衡点)

​	5 发生Full GC的间隔足够的长

#### 2.2 方法(常见的调优策略)

​	1 减少创建对象的数量

​	2 减少全局变量和大对象

​	3 调整新生代、老年代的大小到最合适

​	4 选择合适的GC收集器，并设置合理的参数(具体参数不同JDK版本会有一些差异，最好参照官方文档设置)

#### 2.3 一些方案

​	1 多数的Java应用不需要在服务器上进行优化(基本的内存配置还是需要的，堆大小，新生代/老年代等配置)

​	2 多数导致GC问题的Java应用，都不是因为参数设置错误，而是代码问题

​	3 在应用上线之前，先考虑将机器的JVM参数设置到最优(最适合)

​	4 JVM优化是到最后不得已才采用的手段(首先应把应用本身(代码)的问题解决好)

​	5 在实际使用中，分析JVM情况优化代码比优化JVM本身要多的多

​	6 如下情况通常不用优化(以下都是些参考数值，需要具体应用具体分析)：

​		a Minor/Young GC执行时间不到50ms

​		b Minor/Young GC执行不频繁，约10s一次

​		c Full GC执行时间不到1s

​		d Full GC执行的频率不算频繁，10分钟或者更长时间一次

#### 2.4 相关经验

​	1 要注意32位和64位的区别，通常32位仅支持2-3g左右的内存

​	2 要注意client模式和server模式的选择(可以选择两种模式都测试一段时间对比哪种模式更好)

​	3 要想GC时间小必须要一个更小的堆。而要保证GC次数足够少，又必须保证一个更大的堆，这两个是有冲突的，只能取其平衡。

​	4 针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值。为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间、通常吧最大、最小设置为相同的值

​	5 新生代和老年代将根据默认的比例(1:2)分配堆内存，可以通过调整二者之间的比率NewRadio来调整，也可以通过-XX:newSize -XX:MaxNewSize来设置其绝对大小，同样，为了防止新生堆收缩，通常把-XX:newSize -XX:MaxNewSize设置为同样大小

​	6 合理规划新生代和老年代的大小(小的新生代会产生更多的YoungGC，大的老年代会降低FullGC的频率。不同的新生代、老年代分配比率会导致不同的GC情况)

​	7 如果应用存在大量的临时对象，应该选择更大的新生代。如果存在相对较多的持久对象，老年代应该适当增大。在抉择时应该本着FullGC尽量少的原则，让老年代尽量缓存常用对象，JVM的默认比例1:2也是这个道理（FullGC一般伴随着暂停(STW)。有FullGC，说明这次GC是发生了STW）

​	8 通过观察应用一段时间，在其在**峰值时**老年代会占多少内存，在不影响FullGC的前提下，根据实际情况加大新生代，但应该给老年代至少预留1/3的增长空间

​	9 线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太大了，一般256k就足用。在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程(栈容量由-Xss参数来设定)

### 3 内存泄漏处理

**内存泄漏导致系统崩溃前的一些现象，比如：**

​	1 每次垃圾回收的时间越来越长，FullGC时间也延长好几秒

​	2 Full的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC

​	3 老年代的内存越来越大，并且每次FullGC后老年代没有内存被释放

​	4 老年代堆空间被占满的情况

​	5 这种情况的解决方式：一般就是根据垃圾回收前后情况对比，同时根据对象引用情况分析，辅助去查找泄漏点

**栈溢出的情况：**

​	通常抛出java.lang.StackOverflowError异常，一般就是递归调用没退出，或者循环调用造成的

**排查问题的相关手段：**

​	JMC/visualVM监控应用(JMX/jstatd远程连接的方式)

​	通常生产环境，尤其是公网的生产环境，一般通过**jfr**导出分析文件，或者dump出相关日志文件hprof等

#### 4 调优实战

​	重点是调优的过程、方法和思路(并不是结果，不同应用情况不一样)

​	内存调整、数据库连接调整、内存泄漏查找等



​	压测web应用，通过工具/jfr等调整jvm，数据库连接等参数，去优化。





















