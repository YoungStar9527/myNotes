# 1 以注册中心为样例的demo

## 1.1 并发编程概述

**多线程并发编程**

​	一个jvm进程里，你除了人家默认给你开启的这个main线程，你还可以在main线程里开启别的线程，比如说上面，你可以通过Thread类开启别的线程，别的线程是跟main线程同时在运行的

​	没有先后顺序，多线程并发运行的时候，本质是CPU在执行各个线程的代码，一个CPU会有一个时间片算法，他一会儿执行main线程，一会儿执行Thread线程，看起来两个线程好像是在同时运行一样

​	只不过CPU执行每个线程的时间特别短，可能执行一次就几毫秒，几微妙，你是感觉不出来的，看起来好像是多个线程并发在运行一样

**什么是并发编程**

​	一句话：用多线程来编程，实现复杂的系统功能，让多个线程同时运行，干各种事情，最终完成一套复杂系统需要干的所有的事儿

​	1、控制多线程实现系统功能

​	2、Java内存模型以及volatile关键字

​	3、线程同步以及通信

​	4、锁优化

​	5、并发编程设计模式：基于多线程实现复杂系统架构

​	6、并发包以及线程池

​	7、案例、还是案例、大量的案例（脱胎于真实的复杂分布式系统）

## 1.2 注册中心实现概览

![image-20211024170848015](架构课并发.assets/image-20211024170848015.png)

## 1.3 以工作线程模式开启微服务的注册和心跳线程

### 1.3.1 常见的几种线程启动方式

Thread 	Runnable 	Callable

```java
new Thread() {

public void run() {

}

}.start();

public class MyThread extends Thread {

public void run() {

}

}

new MyThread().start();

new Thread(new Runnable() {

public void run() {

}

}).start();

public class MyRunnable implements Runnable {

public void run() {

}

}

new Thread(new MyRunnable()).start();
```



### 1.3.2 相关工程概述

两个工程

（1）register-server：负责接收各个服务的请求

​	是可以独立部署和启动的，启动了以后，他会以一个web工程的方式来启动，启动之后就是监听各个服务发送过来的http请求，注册、心跳、下线

​	我们到时候就可以认为是有一个main方法直接运行就启动也可以，现在很流行的spring boot，你直接运行main，人家就给你启动一个web服务器，你在工程里，如果使用spring web mvc实现了一个controller接口，就可以接受请求了

（2）register-client：组件，依赖包，各个服务需要引入这个依赖，在服务启动的时候就可以去让register-client来运行，来跟register-server进行通信，比如说完成这个注册，或者是心跳的通知

​	他不是独立启动的，他其实是一个依赖包，你可以把这个东西打包发布到maven nexus私服里去，你的公司里各个服务，必须依赖这个register-client，然后启动服务的时候，一般会调用regsiter-client的API，创建一个组件，启动这个组件

​	由rgister-client组件去跟register-server进行交互

（3）spring cloud eureka

​	人家Spring Cloud的微服务注册中心，eureka，大概就是这个意思，人家也是分eureka-server，是独立部署和启动的，就是一个web工程；eureka-client，各个服务都需要依赖eureka-client，服务启动就创建一个eureka-client实例；eureka-client帮各个服务跟eureka-server进行通信，注册、心跳、下线

（4）工作线程

​	我们启动了一个jvm进程，main线程，RegisterClientWorker线程

​	main线程负责启动了RegisterClientWorker线程，其实干完这些事情以后，main线程就结束了，结束了以后但是jvm进程不会退出？为什么呢，有一个工作线程，就是RegisterClientWorker线程一直在运行

​	**所以jvm进程是不会退出的，会一直存在**

​	**只要有工作线程一直在运行，没有结束，那么jvm进程是不会退出的**

**核心demo代码：**

模拟注册及心跳逻辑

```java
public class RegisterClientWorker extends Thread 
..............................
		if(!finishedRegister) {
			// 应该是获取当前机器的信息
			// 包括当前机器的ip地址、hostname，以及你配置这个服务监听的端口号
			// 从配置文件里可以拿到
			RegisterRequest registerRequest = new RegisterRequest();
			registerRequest.setServiceName(SERVICE_NAME);
			registerRequest.setIp(IP); 
			registerRequest.setHostname(HOSTNAME);
			registerRequest.setPort(PORT);  
			registerRequest.setServiceInstanceId(serviceInstanceId);    
			
			RegisterResponse registerResponse = httpSender.register(registerRequest);
			
			System.out.println("服务注册的结果是：" + registerResponse.getStatus() + "......");   
			
			// 如果说注册成功的话
			if(RegisterResponse.SUCCESS.equals(registerResponse.getStatus())) {
				this.finishedRegister = true;
			} else {
				return;
			}
		}
		
		// 如果说注册成功了，就进入while true死循环
		if(finishedRegister) {
			HeartbeatRequest heartbeatRequest = new HeartbeatRequest();
			heartbeatRequest.setServiceInstanceId(serviceInstanceId);
			HeartbeatResponse heartbeatResponse = null;
			
			while(true) {
				try {
					heartbeatResponse = httpSender.heartbeat(heartbeatRequest);
					System.out.println("心跳的结果为：" + heartbeatResponse.getStatus() + "......");
					Thread.sleep(30 * 1000); 
				} catch (Exception e) {  
					e.printStackTrace();
				}
			}
		}
 	
```

## 1.4 微服务注册中心的服务注册功能实现

register-server 工程 服务注册相关核心逻辑

```java
	/**
	 * 核心的内存数据结构：注册表
	 * 
	 * Map：key是服务名称，value是这个服务的所有的服务实例
	 * Map<String, ServiceInstance>：key是服务实例id，value是服务实例的信息
	 * 
	 */
	private Map<String, Map<String, ServiceInstance>> registry = 
			new HashMap<String, Map<String, ServiceInstance>>();
	
	/**
	 * 服务注册
	 * @param serviceInstance 服务实例
	 */
	public void register(ServiceInstance serviceInstance) {
		Map<String, ServiceInstance> serviceInstanceMap = 
				registry.get(serviceInstance.getServiceName());
		
		if(serviceInstanceMap == null) {
			serviceInstanceMap = new HashMap<String, ServiceInstance>();
			registry.put(serviceInstance.getServiceName(), serviceInstanceMap);
		}
		
		serviceInstanceMap.put(serviceInstance.getServiceInstanceId(), 
				serviceInstance);
		
		System.out.println("服务实例【" + serviceInstance + "】，完成注册......");  
		System.out.println("注册表：" + registry); 
	}
```



## 1.5 微服务注册中心的心跳续约功能实现

register-server 工程 心跳续约相关核心逻辑

```java
		/**
		 * 最近一次心跳的时间
		 */
		private Long latestHeartbeatTime = System.currentTimeMillis();

		/**
		 * 续约，你只要发送一次心跳，就相当于把register-client和register-server之间维护的一个契约
		 * 进行了续约，我还存活着，我们俩的契约可以维持着
		 * @param latestHeartbeatTime
		 */
		public void renew() {
			this.latestHeartbeatTime = System.currentTimeMillis(); 
			System.out.println("服务实例【" + serviceInstanceId + "】，进行续约：" + latestHeartbeatTime);  
		}
		
		/**
		 * 判断当前服务实例的契约是否还存活
		 * @return
		 */
		public Boolean isAlive() {
			Long currentTime = System.currentTimeMillis();
			if(currentTime - latestHeartbeatTime > NOT_ALIVE_PERIOD) {
				System.out.println("服务实例【" + serviceInstanceId + "】，不再存活");
				return false;
			}
			System.out.println("服务实例【" + serviceInstanceId + "】，保持存活");
			return true;
		}
```



## 1.6 微服务存活状态监控线程的实现

register-server 工程 监控线程相关核心逻辑

```java
		private Registry registry = Registry.getInstance();
		
		@Override
		public void run() {
			Map<String, Map<String, ServiceInstance>> registryMap = null;
			
			while(true) {
				try {
					registryMap = registry.getRegistry();
					
					for(String serviceName : registryMap.keySet()) {
						Map<String, ServiceInstance> serviceInstanceMap = 
								registryMap.get(serviceName);
						
						for(ServiceInstance serviceInstance : serviceInstanceMap.values()) {
							// 说明服务实例距离上一次发送心跳已经超过90秒了
							// 认为这个服务就死了
							// 从注册表中摘除这个服务实例
							if(!serviceInstance.isAlive()) {
								registry.remove(serviceName, serviceInstance.getServiceInstanceId()); 
							}
						}
					}
					
					Thread.sleep(CHECK_ALIVE_INTERVAL);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
```



![image-20211103054829069](架构课并发.assets/image-20211103054829069.png)



## 1.7 以daemon模式运行微服务存活状态监控线程

register-server 工程 监控线程相关核心逻辑

​	假如说微服务注册中心负责接收请求的核心工作线程不知道为啥都停止了，那么说明这个微服务注册中心必须停止啊，结果你的那个监控微服务存活状态的线程一直在那儿运行着，卡着，会导致微服务注册中心没法退出的！因为jvm进程没法结束

所以说针对这种情况，一般会将后台运行的线程设置为daemon线程

```java
	/**
	 * 负责监控微服务存活状态的后台线程
	 */
	private Daemon daemon = new Daemon();
	
	/**
	 * 启动后台线程
	 */
	public void start() {
		daemon.setDaemon(true);
		daemon.start();
	}
```

**在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。**

​	所谓守护 线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

​	**用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。**

**将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：**

​	(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 

​	(2) 在Daemon线程中产生的新线程也是Daemon的。

​	(3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

引用：https://www.cnblogs.com/luochengor/archive/2011/08/11/2134818.html

# 2 Thread相关知识

## 2.1 ThreadGroup概念

**简介：**

​	ThreadGroup就是线程组，其实意思就是你可以把一堆线程加入一个线程组里

​	**java里，每个线程都有一个父线程的概念，就是在哪个线程里创建这个线程，那么他的父线程就是谁**

​	**然后每个线程都必然属于一个线程组，默认情况下，你要是创建一个线程没指定线程组，那么就会属于父线程的线程组了，main线程的线程组就是main ThreadGroup**

​	也可以手动创建一个线程组，将线程加入这个线程组中

**场景：**

​	举例来说，java都是通过main启动的，那么有一个主要的线程就是mian线程，在main线程里启动的线程，父线程就是main线程，就这么简单。

​	**为线程服务，用户通过使用线程组的概念批量管理线程，如批量停止或挂起等。**

**方法简介：**

```
enumerate()：复制线程组里的线程
activeCount()：获取线程组里活跃的线程
getName()、getParent()、list()，等等
interrupt()：打断所有的线程
destroy()：一次性destroy所有的线程
```

**代码实例：**

![image-20211104072036613](架构课并发.assets/image-20211104072036613.png)

**输出结果：**

![image-20211104072047478](架构课并发.assets/image-20211104072047478.png)

**总结：**

​	默认线程会加入父线程的ThreadGroup，或者你自己手动创建ThreadGroup，ThreadGroup也有父ThreadGroup，ThreadGroup可以包裹一大堆的线程，然后统一做一些操作，比如统一复制、停止、销毁

**PS:ThreadGrdoup很少用，其实如果你要自己封装一堆线程的管理组件，我觉得你完全可以自己写**

## 2.2 设置线程优先级

**概念：**

​	设置线程优先级，理论上可以让优先级高的线程先尽量多执行

​	**一般实践中很少弄这个东西，因为这是理论上的，可能你设置了优先级，人家cpu结果也还是没按照这个优先级来执行线程**

​	这个优先级一般是在1~10之间

​	**ThreadGroup也可以指定优先级，线程优先级不能大于ThreadGroup的优先级(这里ThreadGroup优先级是最大优先级，默认为10，也可以指定其他数字)**

​	一般就是用默认的优先级就ok了，默认他会用父线程的优先级，就是5

**对应方法及源码：**

```java
public
class Thread implements Runnable {
..................................
    /**
     * The minimum priority that a thread can have.
     */
    public final static int MIN_PRIORITY = 1;
..................................
    /**
     * The maximum priority that a thread can have.
     */
    public final static int MAX_PRIORITY = 10;
..................................
   public final void setPriority(int newPriority) {
        ThreadGroup g;
        checkAccess();
    	//优先级范围验证，不在1-10之间之间抛参数异常
        if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
            throw new IllegalArgumentException();
        }
	    //线程组肯定有的，如果没有默认指定，就是父线程的线程组(父线程就是创建当前线程的线程)
        if((g = getThreadGroup()) != null) {
            if (newPriority > g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }
            //设置优先级为当前传入优先级
            //这个是Thread的native方法，设置优先级
            setPriority0(priority = newPriority);
        }
    }
..................................
```

**代码示例：**

​	![image-20211104201255949](架构课并发.assets/image-20211104201255949.png)

结果表示..并没有什么用

![image-20211104201301920](架构课并发.assets/image-20211104201301920.png)

## 2.3 Thread源码

### 2.3.1 初始化

```java
public
class Thread implements Runnable {
................
   //无参构造
   public Thread() {
    	//不指定线程名的话就自动生成，其中nextThreadNum为同步方法
        init(null, null, "Thread-" + nextThreadNum(), 0);
   }
   
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null, true);
    }
    
    /**
     * Initializes a Thread.
     *
     * @param g the Thread group  线程组
     * @param target the object whose run() method gets called  Runnable实例对象
     * @param name the name of the new Thread  线程名
     * @param stackSize the desired stack size for the new thread, or
     *        zero to indicate that this parameter is to be ignored. 可以自定义指定线程栈长度
     * @param acc the AccessControlContext to inherit, or
     *            AccessController.getContext() if null 不知道干嘛的
     * @param inheritThreadLocals if {@code true}, inherit initial values for
     *            inheritable thread-locals from the constructing thread 不知道干嘛的，表面意思是继承ThreadLocal
     */
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals) {
        //线程名不能为空，否则抛异常
        if (name == null) {
            throw new NullPointerException("name cannot be null");
        }
	
        this.name = name;
		//这里currentThread()指的就是创建改线程的线程，也就是父线程
        Thread parent = currentThread();
        SecurityManager security = System.getSecurityManager();
        //如果没有指定线程组，就为父线程的线程组
        if (g == null) {
            /* Determine if it's an applet or not */

            /* If there is a security manager, ask the security manager
               what to do. */
            if (security != null) {
                g = security.getThreadGroup();
            }

            /* If the security doesn't have a strong opinion of the matter
               use the parent thread group. */
            if (g == null) {
                g = parent.getThreadGroup();
            }
        }

        /* checkAccess regardless of whether or not threadgroup is
           explicitly passed in. */
        g.checkAccess();

        /*
         * Do we have the required permissions?
         */
        if (security != null) {
            if (isCCLOverridden(getClass())) {
                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
            }
        }

        g.addUnstarted();

        this.group = g;
        //父线程为守护线程，则该线程也一样，反之亦然
        this.daemon = parent.isDaemon();
        //优先级和父线程一致
        this.priority = parent.getPriority();
        //类加载器与父线程一致
        if (security == null || isCCLOverridden(parent.getClass()))
            this.contextClassLoader = parent.getContextClassLoader();
        else
            this.contextClassLoader = parent.contextClassLoader;
        this.inheritedAccessControlContext =
                acc != null ? acc : AccessController.getContext();
        this.target = target;
        setPriority(priority);
        if (inheritThreadLocals && parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
        /* Stash the specified stack size in case the VM cares */
        this.stackSize = stackSize;

        /* Set thread ID */
        //指定线程id，nextThreadID为同步方法，线程id为自增的
        tid = nextThreadID();
    }
....................
```

**总结：**

（1）创建你的线程，就是你的父线程

（2）如果你没有指定ThreadGroup，你的ThreadGroup就是父线程的ThreadGroup

（3）你的daemon状态默认是父线程的daemon状态

（4）你的优先级默认是父线程的优先级

（5）如果你没有指定线程的名称，那么默认就是Thread-0格式的名称

（6）你的线程id是全局递增的，从1开始

### 2.3.2 线程启动过程



```java
   
   public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         * threadStatus就是线程状态，NEW初始化状态就是0
         * 这里只有第一次调用start方法threadStatus才为0，threadStatus的值由本地方法native 底层jvm,c++去修改
         * 这里判断如果多次调用start直接抛出异常
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
       //添加到线程组中
        group.add(this);
		
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                //这里如果started还是false则进入if
                //说明start0的native本地方法抛出了异常
                if (!started) {
                    //通知线程组，线程启动失败
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
```

**总结：**

（1）一旦启动了线程之后，就不能再重新启动了，多次调用start()方法，因为启动之后，threadStatus就是非0的状态了，此时就不能重新调用了

（2）你启动线程之后，这个线程就会加入之前处理好的那个线程组中

（3）启动一个线程实际上走的是native方法，start0()，会实际的启动一个线程

（4）一个线程启动之后就会执行run()方法

**PS:线程基本的状态转换参考 儒猿并发编程实战**

### 2.3.3 sleep

```java
    /**
     * Causes the currently executing thread to sleep (temporarily cease
     * execution) for the specified number of milliseconds, subject to
     * the precision and accuracy of system timers and schedulers. The thread
     * does not lose ownership of any monitors.
     * 可以指定线程睡眠多少毫秒
     * @param  millis
     *         the length of time to sleep in milliseconds
     *
     * @throws  IllegalArgumentException
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;

    /**
     * Causes the currently executing thread to sleep (temporarily cease
     * execution) for the specified number of milliseconds plus the specified
     * number of nanoseconds, subject to the precision and accuracy of system
     * timers and schedulers. The thread does not lose ownership of any
     * monitors.
     *
     * @param  millis
     *         the length of time to sleep in milliseconds
     *
     * @param  nanos 微秒，没什么用
     *         {@code 0-999999} additional nanoseconds to sleep
     *
     * @throws  IllegalArgumentException
     *          if the value of {@code millis} is negative, or the value of
     *          {@code nanos} is not in the range {@code 0-999999}
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public static void sleep(long millis, int nanos)
    throws InterruptedException {
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }
		//如果大于500000，也就是四舍五入，大于1毫秒的一半时候，就加一
		//这里sleep最小单位是毫秒，微秒作用不大
        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
            millis++;
        }

        sleep(millis);
    }
```

JDK 1.5之后就引入了TimeUnit这个类，可以替代sleep

```


TimeUnit.HOURS.sleep(1)
TimeUnit.MINUTES.sleep(5)
TimeUnit.SECONDS.sleep(30)
TimeUnit.MILLISECONDS.sleep(500)
```

### 2.3.4 yield

```java
    /**
     * A hint to the scheduler that the current thread is willing to yield
     * its current use of a processor. The scheduler is free to ignore this
     * hint.
     *
     * <p> Yield is a heuristic attempt to improve relative progression
     * between threads that would otherwise over-utilise a CPU. Its use
     * should be combined with detailed profiling and benchmarking to
     * ensure that it actually has the desired effect.
     *
     * <p> It is rarely appropriate to use this method. It may be useful
     * for debugging or testing purposes, where it may help to reproduce
     * bugs due to race conditions. It may also be useful when designing
     * concurrency control constructs such as the ones in the
     * {@link java.util.concurrent.locks} package.
     */

    public static native void yield();
```

​	yield一半来说没什么用，极少会用到。

​	**概念：**

​	**yield 即 "谦让"，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。**

​	**总结：**

​	yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源

### 2.3.5 join



```java
    /**
     * Waits for this thread to die.
     *
     * <p> An invocation of this method behaves in exactly the same
     * way as the invocation
     *
     * <blockquote>
     * {@linkplain #join(long) join}{@code (0)}
     * </blockquote>
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public final void join() throws InterruptedException {
        join(0);
    }
    
    /**
     * Waits at most {@code millis} milliseconds for this thread to
     * die. A timeout of {@code 0} means to wait forever.
     *
     * <p> This implementation uses a loop of {@code this.wait} calls
     * conditioned on {@code this.isAlive}. As a thread terminates the
     * {@code this.notifyAll} method is invoked. It is recommended that
     * applications not use {@code wait}, {@code notify}, or
     * {@code notifyAll} on {@code Thread} instances.
     *
     * @param  millis
     *         the time to wait in milliseconds
     *
     * @throws  IllegalArgumentException
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }

    public final synchronized void join(long millis, int nanos)
    throws InterruptedException {

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
            millis++;
        }

        join(millis);
    }
    
    public final native void wait(long timeout) throws InterruptedException;

```

 **join() 的作用**

​	**让父线程等待子线程结束之后才能继续运行** 

**示例：**

```java
// 父线程
public class Parent {
    public static void main(String[] args) {
        // 创建child对象，此时child表示的线程处于NEW状态
        Child child = new Child();
        // child表示的线程转换为RUNNABLE状态
        child.start();
        // 等待child线程运行完再继续运行
        child.join();
    }
}
```

**调用链：**

​	Parent.main() -> child.join() -> child.join(0) -> child.wait(0)（此时 Parent线程会获得 child 实例作为锁，其他线程可以进入 child.join() ，但不可以进入 child.join(0)， 因为child.join(0)是同步方法）。

​	如果 child 线程是 Active，则调用 child.wait(0)（为了防止子线程 spurious wakeup, 需要将 wait(0) 放入 while(isAlive()) 循环中。

​	一旦 child 线程不为 Active （状态为 TERMINATED）, child.notifyAll() 会被调用-> child.wait(0)返回 -> child.join(0)返回 -> child.join()返回 -> Parent.main()继续执行, 子线程会调用this.notify()，child.wait(0)会返回到child.join(0) ，child.join(0)会返回到 child.join(), child.join() 会返回到 Parent 父线程，Parent 父线程就可以继续运行下去了。

**总结：**

(1) 三个方法都被final修饰，无法被子类重写。

(2) join(long), join(long, long) 是synchronized method，同步的对象是当前线程实例。

(2) 无参版本和两个参数版本最终都调用了一个参数的版本。

(3) join() 和 join(0) 是等价的，表示一直等下去；join(非0)表示等待一段时间。

从源码可以看到 join(0) 调用了Object.wait(0)，其中Object.wait(0) 会一直等待，直到被notify/中断才返回。

while(isAlive())是为了防止子线程伪唤醒(spurious wakeup)，只要子线程没有TERMINATED的，父线程就需要继续等下去。

(4) join() 和 sleep() 一样，可以被中断（被中断时，会抛出 InterrupptedException 异常）；不同的是，join() 内部调用了 wait()，会出让锁，而 sleep() 会一直保持锁。

引用：https://www.cnblogs.com/huangzejun/p/7908898.html

**实战：**

​	基于join实现服务注册线程的阻塞式运行

```java
	public void start() {
		try {
			// 一旦启动了这个组件之后，他就负责在服务上干两个事情
			// 第一个事情，就是开启一个线程向register-server去发送请求，注册这个服务
			// 第二个事情，就是在注册成功之后，就会开启另外一个线程去发送心跳
			
			// 我们来简化一下这个模型
			// 我们在register-client这块就开启一个线程
			// 这个线程刚启动的时候，第一个事情就是完成注册
			// 如果注册完成了之后，他就会进入一个while true死循环
			// 每隔30秒就发送一个请求去进行心跳
			RegisterWorker registerWorker = new RegisterWorker();
			registerWorker.start();
			registerWorker.join();
			
			HeartbeatWorker heartbeatWorker = new HeartbeatWorker();
			heartbeatWorker.start();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
```

### 2.3.6 interrupt

```java
    /**
     * Interrupts this thread.
     *
     * <p> Unless the current thread is interrupting itself, which is
     * always permitted, the {@link #checkAccess() checkAccess} method
     * of this thread is invoked, which may cause a {@link
     * SecurityException} to be thrown.
     *
     * <p> If this thread is blocked in an invocation of the {@link
     * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
     * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
     * class, or of the {@link #join()}, {@link #join(long)}, {@link
     * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
     * methods of this class, then its interrupt status will be cleared and it
     * will receive an {@link InterruptedException}.
     *
     * <p> If this thread is blocked in an I/O operation upon an {@link
     * java.nio.channels.InterruptibleChannel InterruptibleChannel}
     * then the channel will be closed, the thread's interrupt
     * status will be set, and the thread will receive a {@link
     * java.nio.channels.ClosedByInterruptException}.
     *
     * <p> If this thread is blocked in a {@link java.nio.channels.Selector}
     * then the thread's interrupt status will be set and it will return
     * immediately from the selection operation, possibly with a non-zero
     * value, just as if the selector's {@link
     * java.nio.channels.Selector#wakeup wakeup} method were invoked.
     *
     * <p> If none of the previous conditions hold then this thread's interrupt
     * status will be set. </p>
     *
     * <p> Interrupting a thread that is not alive need not have any effect.
     *
     * @throws  SecurityException
     *          if the current thread cannot modify this thread
     *
     * @revised 6.0
     * @spec JSR-51
     */
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
```

**作用：**

​	其实Thread.interrupt()并不会中断线程的运行，它的作用仅仅是为线程设定一个状态而已，即标明线程是中断状态，这样线程的调度机制或我们的代码逻辑就可以通过判断这个状态做一些处理，比如sleep()方法会抛出异常，或是我们根据isInterrupted()方法判断线程是否处于中断状态，然后做相关的逻辑处理。

   处于阻塞的线程，即在执行Object对象的wait()、wait(long)、wait(long, int)，或者线程类的join()、join(long)、join(long, int)、sleep(long)、sleep(long,int)方法后线程的状态，当线程调用interrupt()方法后，这些方法将抛出InterruptedException异常，并清空线程的中断状态，即isInterrupted()返回false

**实战1：**

```java
	public static void main(String[] args) throws Exception {
		MyThread thread = new MyThread();
		thread.start();
		
		Thread.sleep(1000);  
		
		thread.setShouldRun(false);  
		thread.interrupt();
	}
	
	private static class MyThread extends Thread {
		
		private Boolean shouldRun = true;
		
		@Override
		public void run() {
			while(shouldRun) {  
				try {
					System.out.println("线程1在执行工作......");  
					Thread.sleep(30 * 1000);  
				} catch (Exception e) {
					e.printStackTrace();     
				}
			}
		}
		
		public void setShouldRun(Boolean shouldRun) {
			this.shouldRun = shouldRun;
		}
		
	}
```

**实战2：**

```java
	public static void main(String[] args) throws Exception {
		Thread thread = new Thread() {
			
			@Override
			public void run() {
				while(!isInterrupted()) {  
					System.out.println("线程1在执行工作......");  
				}
			}
			
		};
		thread.start();
		
		Thread.sleep(1000);  
		
		thread.interrupt();
	}
```

**实战3：**

基于interrupt实现微服务优雅关闭心跳线程

​	分布式系统里面，一般会有一些核心的工作线程，现在如果这个系统要关闭，一般会设计一个shutdown方法，在这个方法里面，会设置各个工作线程是否需要运行的标志位为false

```java
	/**
	 * 心跳线程
	 * @author zhonghuashishan
	 *
	 */
	private class HeartbeatWorker extends Thread {
		
		@Override
		public void run() {
			// 如果说注册成功了，就进入while true死循环
			HeartbeatRequest heartbeatRequest = new HeartbeatRequest();
			heartbeatRequest.setServiceName(SERVICE_NAME);  
			heartbeatRequest.setServiceInstanceId(serviceInstanceId);
			
			HeartbeatResponse heartbeatResponse = null;
			
			while(isRunning) { 
				try {
					heartbeatResponse = httpSender.heartbeat(heartbeatRequest);
					System.out.println("心跳的结果为：" + heartbeatResponse.getStatus() + "......");
					Thread.sleep(HEARTBEAT_INTERVAL);   
				} catch (Exception e) {  
					e.printStackTrace();
				}
			}
	 	}
		
	}
```

​	对各个工作线程都执行interrupt

​	因为各个工作线程可能都在不断的while循环运行，但是每次执行完一次之后，都会进入休眠的状态，sleep 30秒

​	如果系统要尽快停止，那么就应该用interrupt打断各个工作线程的休眠，让他们判断是否运行的标志位为false，就立刻退出

```java
public class RegisterClient 

	/**
	 * 停止RegisterClient组件
	 */
	public void shutdown() {
		this.isRunning = false;
		this.heartbeatWorker.interrupt(); 
	}
```

# 3 volatile相关知识

## 3.1 总线加锁机制和MESI缓存一致性协议的工作原理

**高速缓存：**

​	CPU不是直接与内存进行交互的，而是通过高速缓存，CPU与高速缓存交互，高速缓存再与内存进行交互。(这样做的好处是为了提高cpu的执行效率，如果因为cpu执行是非常快的，而内存存取速度相对较慢，直接与内存交互的话，效率会受到影响)

**多线程与高速缓存：**

​	当线程对变量进行操作的时候，比如i++,先由cpu对i进行操作，然后在放入高速缓存中，然后再刷入内存中，这样在单线程是没有问题的，在多线程环境下，就会产生不同线程的高速缓存中的值不一致的问题了(每个线程cpu，之间的高速缓存是相互独立的)。

**总线加锁与MESI缓存一致性：**

为了解决缓存不一致的问题，通常来说有两种解决办法

**1 在总线加LOCK#锁的方式**

​	早期的CPU就是在总线上加LOCK#锁的方式来解决缓存不一致的问题的，加锁的话就相当于串行化了，共享变量只能通过其他线程执行完毕后，才能读取变量所在的内存进行相应操作

​	会导致锁在锁住总线期间，其他CPU无法访问内存，导致效率低下

**2 通过MESI缓存一致性**

​	Intel的缓存一致性协议是比较通用的

​	MESI协议保证了每个缓存中使用的共享变量的副本是一致的

​	**核心思想是：CPU写数据时，发现操作的变量是共享变量，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量的时候，会发现自己的缓存是无效的，会重新从内存进行读取(cpu嗅探机制)**

​	底层是通过：:lock前缀指令 -> 内存屏障 来实现修改缓存，刷新主内存这套流程的

![image-20211124070854937](架构课并发.assets/image-20211124070854937.png)



## 3.2 并发编程中的三大特性：可见性、原子性、有序性

**原子性：即为一个或多个操作，要不全部执行，要不全部不执行。**

**可见性：多个线程同时访问一个变量的时候，其中一个线程修改了该变量，其他线程立即就能看到修改的值。**

**有序性：**

**就是程序执行的顺序按照代码的先后顺序去执行**

因为cpu为了提高执行效率等原因，会对代码进行指令重排序

**禁止指令重排序/happens-before原则等都是有序性问题**

## 3.3 Java内存模型

详细参考：jvm笔记-高效并发

这里的java内存模型与cpu与内存的交互是对应的。

![image-20211124072913444](架构课并发.assets/image-20211124072913444.png)

​	**read(从主内存读取),load(将主内存读取到的值写入工作内存),use(从工作内读取数据来计算),assign(将计算好的值重新赋值到工作内存中),store(将工作内存数据写入主存),wirte(将store过去的变量值赋值给主内存中的变量)**

![image-20211124072741823](架构课并发.assets/image-20211124072741823.png)

规定：



引用：https://www.cnblogs.com/dolphin0520/p/3920373.html

https://blog.csdn.net/Jarvenman/article/details/103969667

3.4 





