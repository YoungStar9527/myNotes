# 1 解决并发问题的常见方法

解决并发问题的常见方法/不会产生并发问题的情况

![image-20210824171756443](儒猿并发编程实战.assets/image-20210824171756443.png)

局部变量，不可变对象就是不会产生并发问题。

ThreadLocal、cas原子类就是解决并发问题的方式之一。

**并发问题的方法分为两大类:无锁和有锁。**

**无锁:局部变量、不可变对象、ThreadLocal、CAS原子类;**

**有锁：synchronized关键字、ReentrantLock可重入锁。**

**局部变量：**局部变量是在对应线程的工作内存中，多线程并不会互相影响。对于栈中的栈帧，方法中的局部变量是存在栈帧里的，栈内存是不共享的。

**不可变对象：**String就是不可变对象，比如 String s = "hello"，"hello"就是不可变的，并不是指向"hello"的s。"hello"+"world"形成

"helloworld"这里"helloworld"是新的字符串(不可变对象)，原来的两个字符串并没有改变.

**ThreadLocal：** 每个线程的ThreadLocal的值都是独立的副本，互相不干扰。

**CAS:**可以多个线程同时执行(**多个线程可以同时执行就是"无锁"，虽然cas是基于"乐观锁"**)，比较并置换思想(compare and swap)。是基于内存地址B、旧的预期值A、要修改的新值B，当内存地址和旧的预期值相等时才会将内存地址V改为新值B。若失败则进入while死循环挂起，直到操作成功。(对应的比较替换方法是基于c++的native方法实现的，可以保证原子性)

**synchronized/ReentrantLock:**都是基于悲观锁的，一个是通过语言层面实现的，一个是基于代码实现的。这里就放在一起分析。

```java

private ReentrantLock reentrantLock = new ReentrantLock();

private int i = 0;

private void addReen(){
    try{
        reentrantLock.lock();
    	i++;
    }finally{
        reetrantLock.unlock();
    }
}

private synchronized void addSynchronized(){
    	i++;
}

```

这里 i++的主要分为3个步骤

1 从主内存读取 i 的值

2 将 i 的值加1

3 将结果再写入主内存

这上面三个操作都可以通过加锁(synchronized/ReentrantLock)来保证原子性的，要不3个一起执行，要不都不执行。

加锁原理如图所示：

![image-20210901161711254](儒猿并发编程实战.assets/image-20210901161711254.png)



# 2 不可变类

## 2.1 如何快速设计一个不可变类

通过不可变类来避免线程安全问题

样例，车辆一个定位功能，实时更新x,y坐标

```java
//正常类
public class Location {

    private double x;

    private double y;

    public Location(double x, double y) {
        this.x = x;
        this.y = y;
    }
	
    //更新坐标
    public void setXY(double x, double y){
        this.x = x;
        this.y = y;
    }
}

//不可变类
public final class LocationFinal {

    private final double x;

    private final double y;

    public LocationFinal(double x, double y) {
        this.x = x;
        this.y = y;
    }

}
```

不可变类/正常类区别

```java
public class CarLocatTracker {

    private Map<String,Location> locationMap = new HashMap<>();

    private Map<String,LocationFinal> locationFinalMap = new HashMap<>();

    //正常类更新坐标
    private void updateCarLocation(String code,double x,double y){
        locationMap.get(code).setXY(x,y);
    }

    //不可变类更新坐标
    //不可变类直接替换整个类，线程安全
    private void updateCarLocationFinal(String code,LocationFinal locationFinal){
        locationFinalMap.put(code,locationFinal);
    }

}
```

**在多线程环境下，非不可变类更新坐标，如图所示：**

![image-20210902144810616](儒猿并发编程实战.assets/image-20210902144810616.png)

**如上图所示，线程2就获取到了一个错误的信息，x为更新后,y为没更新的值，这是一个车辆没有到达过得位置**



通过上面的例子，我们大概了解了使用可变的类会引发什么样问题，以及如何将一个类改造成**不可变类，来解决线程安全问题**。最后我们总结一下实现不可变类的一些思路:

1.使用final关键字修饰所有成员变量，避免其被修改，也可以保证多线程环境下被final关键字修饰的变量所引用的对象的初始化安全，即final修饰的字段在其他线程可见时，必定是初始化完成的。

⒉使用private修饰所有成员变量，可以防止子类及其他地方通过引用直接修改变量值。

3.禁止提供修改内部状态的公开接口(比如我们前面例子中的setXY方法)

4.禁止不可变类被外部继承，防止子类改变其定义的方法的行为。

5.如果类中存在数组或集合，在提供给外部访问之前需要做防御性复制

前面4点比较好理解，我们在前面改造Location为不可变类的过程中都有运用到，第5点则需要另外做一下说明

**PS:不可变类避免线程安全问题的主要思想就是在初始化后(构造方法初始化数据)整个类的数据都不可改变，多线程访问的话要不就是整个类替换。就不会有线程安全问题**

```java
//防御性复制
public class DefensiveReplicaDemo {

    private final List<Integer> data = new ArrayList<>();

    private final List<Integer> dataFinal = new ArrayList<>();

    public DefensiveReplicaDemo() {
        data.add(1);
        data.add(2);
        data.add(3);
        dataFinal.add(1);
        dataFinal.add(2);
        dataFinal.add(3);
    }

    public List<Integer> getData() {
        return data;
    }

    /**
     * 防御性复制，如果修改这个集合就会抛出异常
     * @return
     */
    public  List<Integer> getDataFinal() {
        return Collections.unmodifiableList(new ArrayList<>(dataFinal));
    }

    public static void main(String[] args) {
        DefensiveReplicaDemo defensiveReplicaDemo = new DefensiveReplicaDemo();
        List<Integer> data = defensiveReplicaDemo.getData();
        List<Integer> dataFinal = defensiveReplicaDemo.getDataFinal();
        //这里的data没有进行防御性复制，就算设置了final还是可以修改List的数据
        data.add(4);
        System.out.println(defensiveReplicaDemo.getData());
        //这个add方法会抛出异常
        //该list为只读，任何修改都会抛出异常
        dataFinal.add(4);
        System.out.println(defensiveReplicaDemo.getDataFinal());
    }
}
```

样例：短信网关系统基于不可变类解决线程安全问题

https://apppukyptrl1086.pc.xiaoe-tech.com/detail/i_60b316f0e4b0017651a0355e/1?from=p_60ab6413e4b07e4d7fd8458a&type=6

## 2.2 等效不可变对象

​	等效不可变对象在在源码中的应用,主要是围绕CopyOnWriteArrayList的原理来展开，**CopyOnWriteArrayList的源码中运用了不可变对象模式，使得集合在进行遍历操作的时候，不用加锁也能保证线程安全。**

```java
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final long serialVersionUID = 8673264195747942595L;

    /** The lock protecting all mutators */
    final transient ReentrantLock lock = new ReentrantLock();

    /** The array, accessed only via getArray/setArray. */
    //主要就是维护了一个array数组
    private transient volatile Object[] array;

    /**
     * Gets the array.  Non-private so as to also be accessible
     * from CopyOnWriteArraySet class.
     */
    //获取数组
    final Object[] getArray() {
        return array;
    }

    /**
     * Sets the array.
     */
    //覆盖数组
    final void setArray(Object[] a) {
        array = a;
    }
.....................................    
}
```

接下来看看CopyOnWriteArrayList在进行数据遍历/获取数据 和新增一个元素的方法：

```java
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable 
    //返回内部维护的数组
	final Object[] getArray() {
        return array;
    }    

	//根据下标获取数组数据
	public E get(int index) {
        return get(getArray(), index);
    }
    
	//根据数组迭代数据遍历
    public Iterator<E> iterator() {
        return new COWIterator<E>(getArray(), 0);
    }

    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //获取旧数组
            Object[] elements = getArray();
            int len = elements.length;
            //根据旧数组的值，生成新数组
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            //新数组覆盖，引用变为新数组了
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }

```

​	在array对象每次被创建之后，其内容就不再被改变。（数组的长度和每个元素都不变）。另外就算我们对**CopyOnWriteArrayList进行集合元素的增删，这里也不是直接改变原数组的元素，而是直接新建了一个新的数组，替换掉array对象。在这个时候，旧的那个数组还是没有改变过。**

**PS:remove删除元素也是改变引用，新数组替换旧数组**

​	但是这里会存在一些差异，因为实例变量**array本质上是一个数组，而数组的各个元素都是一个对象，每个对象内部的状态是可以替换的(就是数组中的对象熟悉可以替换/改变)**。因此**实例变量并非严格意义上的不可变对象，所以我们称之为等效不可变对象**。

多线程读写数据如图所示

![image-20210902175443087](儒猿并发编程实战.assets/image-20210902175443087.png)

​	假设线程1在遍历元素的时候，读到了元素1，但是还没有读到元素2的时候，线程2添加了元素3，这个时候线程1是无法读取到元素3的。这是因为线程1和线程2操作的数组不是同一个数组。 **这也是CopyOnWriteArrayList的一个特点：弱一致性。意思就是说线程1看到的是某一时刻的一份“快照数据”，无法保证能读取到最新的数据**

**使用场景：**

​	JDBC驱动程序列表这种数据，因为驱动程序变更的情况比较少，但是遍历这个驱动程序列表的情况比较多，所以是符合读多写少的特性，所以这个使用CopyOnWriteArrayList来维护比较合适。

```java
package java.sql;

public class DriverManager {
....................

    // List of registered JDBC drivers
    //registerDrivers就是用来保存不同的数据库驱动的,注册数据库驱动就保存再这里
    private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();
    private static volatile int loginTimeout = 0;
    private static volatile java.io.PrintWriter logWriter = null;
    private static volatile java.io.PrintStream logStream = null;
    // Used in println() to synchronize logWriter
    private final static  Object logSync = new Object();

    /* Prevent the DriverManager class from being instantiated. */
    private DriverManager(){}
    
}
```

# 3 Thread线程状态



引用：https://www.cnblogs.com/huangzejun/p/7908898.html
