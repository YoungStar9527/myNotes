# 1 算法简介

## 1.1 二分查找

仅在有序的数组中才能使用

查找次数是最多log₂N

每次都查找中间的元素，对就返回，不对就继续查找，直到找到为止，或者未找到返回null

```java
public static Integer binarySearch(int[] list,int item){
    //指定下标查找范围
    int low = 0;
    int high = list.length-1;
    while(low<=high){
        //在java中int除法不是整数就向下取整
        int mid = (low+high)/2;
        //取中间元素
        int guess = list[mid];
        if(guess == item){
            //找到直接返回
            return mid;
        }
        //item比mid对应值小
        if(guess > item){
            high = mid-1;
        //数字大了
        }else{
            low = mid + 1;
        }
    }
    return null;
}
```

## 1.2 大O表示法

常见的大O表示

O(log n) 对数时间 -- n越大对数时间增长的越慢

O(n) 线性时间

O(n * log n)

O(n²) 

O(n!) 阶乘

大O表示法是指出算法有多快，表示操作数的

大O表示法指出了最糟糕情况下的运行时间

## 1.3 旅行商算法

旅行商要前往5个城市，计算出旅途最短的路径。为此需要考虑前往这些城市的各种可能途径。

该算法目前只有通过O(n!) 阶乘的方式去计算

## 1.4 总结

O(log n) 比 O(n)快，n越大，就快越多

算法的运行时间是从其增速的角度考考量的

算法的运行时间用大O表示法来表示

# 2 选择排序

## 2.1 数组与链表

**内存的工作原理：超市的寄存东西的抽屉，计算机内存就像是很多抽屉的集合，每个抽屉都有地址。**

![image-20210627162101475](算法图解笔记.assets/image-20210627162101475.png)

**数组：**

​	1 数组在内存中是相连的

​	2 每次新增，如果相连后续地址没位置，就需要整个数组重新转移

​	3 每次删除，都需要重新转移删除下标的后面所有的地址

​	4 插入中间元素则需要整个后续元素移动地址，还可能导致整个数组重新转移

​	5 数组知道每个数组元素的地址，因为数组是相连的，知道起始数组的位置，根据简单的数学运算就知道每个数组下标的位置

​	6 所以数组的新增、删除效率较低，查询效率较高

**PS:可以建立数组时预留一些地址占用，这样新增数据就不用担心，整个数组转移的问题。不过该方案也有，占用额外空间和预留地址用完后的局限性的问题。**

**链表：**

​	1 链表元素可以存储在内存中的任何地方

​	2 链表的每个元素都存储了下一个元素的地址，从而使一系列的随机内存地址串在一起

​	3 链表的新增、插入中间元素、删除都很快，只需要对应元素修改内存地址的指针即可

​	4 链表的想查询靠后的链表数据，需要从第一个开始查，一直查到对应位置才行。因为链表对应元素只知道下一个元素的地址，无法直接查询到对应的链表数据，需要遍历链表的每个元素

​	5 如果不知道需要插入、删除元素的地址，也需要遍历链表找到对应地址才能进行插入、删除

​	6 所以链表的插入，删除很快，查询较慢

## 2.2 选择排序/冒泡排序

### 2.2.1 算法图解选择排序

算法图解选择排序思路：

1 先写一个找出最小元素的方法

2 循环数组找出最小元素赋值给新数组

**3 每次赋值给新数组的动作，都会将原数组对应最小元素出队,原数组的长度-1**

4 所以查找的次数为 n + (n-1) + (n-2)...1

5 约为 n * (1/2*(n+1))

6 大O 表示法为 O(n²)

```java
    /**
     * 算法图解选择排序，python数组有根据下标出队的功能
     * java 模拟一个出队功能
     */
    public static int[] arrPop(int[] arr,int index){
        //排除index,则新数组长度-1
        int[] arrNew = new int[arr.length-1];
        int j = 0;
        for(int i = 0; i < arr.length;i++){
            //将除了index对应的数据重新复制到新数组
            if(i != index){
                arrNew[j]=arr[i];
                j++;
            }
        }
        return arrNew;
    }

    /**
     * 找出数组中最小的元素下标
     */
    public static int findSmall(int[] arr){
        int minIndex = 0;
        //从第1位开始找，因为第0位无须再重复比较
        for(int i = 1;i < arr.length; i++){
            if(arr[i]<arr[minIndex]){
                minIndex = i;
            }
        }
        return minIndex;
    }

    /**
     * 选择排序实现
     */
    public static int[] selectionSort(int[] arr){
        int[] arrNew = new int[arr.length];
        int length = arr.length;
        //找n次
        for(int i = 0; i < length; i++){
            //取得最小下标
            int smallIndex = findSmall(arr);
            //将最小下标给到新数组第一位
            arrNew[i] = arr[smallIndex];
            //将最小下标从数组中排出，原数组的长度-1
            arr = arrPop(arr,smallIndex);
        }
        return arrNew;
    }
```



### 2 正常套路选择排序

正常套路选择排序思路：

1 查找n次

**2 每次查找都将最小的值找出来，和当前下标换位置**

**3 然后从当前下标开始再继续找，所以每换一次位置，后续的查找就-1次查找次数**

4 所以查找的次数为 n + (n-1) + (n-2)...1

5 约为 n * (1/2*(n+1))

6 大O 表示法为 O(n²)

查找次数和思路，算法图解版是一样的，实现略有差别

```java
    /**
     * 正常套路选择排序实现
     * @param arr
     * @return
     */
    public static int[] selectionSortJava(int[] arr){
        //查找n次
        for(int i = 0; i < arr.length; i++){
            //当前下标
            int minItem = i;
            for(int j = i+1; j < arr.length;j++){
                //从当前下标往后找，找到最小
                if(arr[j]<arr[minItem]){
                    minItem = j;
                }
            }
            //如果当前下标不是最小的，则当前下标和最小下标换位置
            if(minItem!=i){
                int item = arr[i];
                arr[i] = arr[minItem];
                arr[minItem] = item;
            }
        }
        return arr;
    }
```



### 3 冒泡排序

冒泡排序思路：

1 查找n次

**2 每次都从第0位开始比对，比下一位大，马上就换位置**

3 继续往后比对，换位置，比对到最后一位为止

**4 每次比对到最后一位，说明最后一位就是最大的数值，因为全部都两两比较了一遍，最大的会被换位置到最后一位**

**5 下一次查询次数就-1，因为最大的已经再最后，无须再比较，以此类推**

6 所以查找的次数为 n + (n-1) + (n-2)...1

7 约为 n * (1/2*(n+1))

8 大O 表示法为 O(n²)

**PS:因为冒泡排序交换的次数比选择排序多，相对而言选择排序的效率更高**

**PS:冒泡排序如果某一次冒泡没有发生任何的交换，可以提前终止，这算是一个小优化**

```java
    /**
     * 冒泡排序
     * @param arr
     * @return
     */
    public static int[] bubbleSort(int[] arr){
        //查找n次
        for(int i = 0; i < arr.length; i++){
            //每次比较后，最后一位都无须再比较了,查找次数-1
            //每次都-1，i次就是-i
            for(int j = 1; j < arr.length-i-1;j++){
                //每次都两两前后比较,后面大就换位置
                if(arr[j-1]>arr[j]){
                    int item = arr[j-1];
                    arr[j-1] = arr[j];
                    arr[j] = item;
                }
            }
        }
        return arr;
    }
```















