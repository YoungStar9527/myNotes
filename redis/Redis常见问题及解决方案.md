# 1 高并发场景下的缓存+数据库双写不一致问题分析与解决方案

**PS:以下问题及解决方案都是基于Cacae Aside Pattern模式**

## 1.1 初级的缓存不一致问题及解决方案

​	**问题：**先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致

​	**解决思路：**先删除缓存，再修改数据库，如果删除缓存成功了，修改数据库失败了，那么数据库是旧数据，缓存中是空的，那么数据不会不一致，因为都读的时候缓存没有，则数据库中的旧数据更新到缓存中

## 1.2 比较复杂的数据不一致问题分析

### 1.2.1 并发场景下的缓存不一致问题

**问题：**

​	数据发生了变更，先删除缓存，然后去修改数据库，此时还没修改

​	这个时候一个读请求过滤，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中

​	数据变更的程序完成了数据库的修改，此时又出现数据库和缓存中数据不一样了

**解决方案：**

​	更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个JVM内部的队列中

​	读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个JVM内部的队列中

​	一个队列对应一个工作线程

​	每个工作线程串行拿到对应的操作，然后一条一条的执行

​	这样的话，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新

​	此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成

**优化点：**

​	一个队列中多个读请求(更新缓存)串在一起是没意义的，可以做过滤。如果发现队列中已经有一个读请求(更新缓存)了，那么就不放这个操作进去了，直接等待前面的更新操作请求完成即可,后续等待的读请求就直接能读取缓存中的数据了。

​	设置一个等待的时间范围，在时间范围内轮询发现可以取到值了就直接返回。超过请求时长可以返回旧值(查数据库)/抛出异常(看业务需要)。

### 1.2.2 高并发场景，该方案应该注意的问题

**1 风险点-读请求长时间阻塞/写操作较多：**

​	可能数据更新很频繁。导致队列积压了大量更新操作，然后读请求大量超时，导致大量请求直接走数据库/异常，真实场景一定需要通过模拟真实的测试，看看更新数据的频率是否能支持。

**优化点：**

​	如果更新操作比较频繁，一个队列积压多个商品库存的更新操作。可以选择部署多个服务，每个服务分摊一些数据的更新操作。

**服务的预估：**

​	单机器：20个内存队列，每个队列可能积压5个写操作(100写QPS)，假如一个写操作20ms完成，20*5=100，读操作等待100ms，还是可以接受的

​	如果写QPS扩大10倍，那么久扩容机器，扩容10倍机器，10台机器，每个机器20个队列

**2 风险点-读请求并发量过高**

​	这里还必须做好压力测试，确保恰巧碰上上述情况的时候。还有一个风险，就是突然间大量读请求会在几十毫秒的延时,在服务上等待，看服务能不能抗的住，需要多少机器才能抗住大的极项情况的峰值

**优化点：**

​	做好读和写比例的优化测试，按照1:99的比例，每秒5万的读QPS,可能只有500次更新操作。每个更新操作可能影响1:1,1:2,1:3的读操作500*3也就是影响1000+的读操作，按照分队列的方案每个读请求等待200ms左右返回都是ok的

**3 风险点-热点商品的路由问题，导致请求的倾斜**

​	万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的压力过大

​	就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大但是的确可能某些机器的负载会高一些

**优化点：**

​	评估实际业务，根据热点商品调整资源倾斜，热点商品多分配队列/机器，及服务器性能等操作

## 1.3 多服务实例部署的请求路由

​	可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务实例上

![image-20210529150706128](Redis常见问题及解决方案.assets/image-20210529150706128.png)











